# üöÄ Epic 1: Idempotency Framework - Comprehensive Implementation Plan

## Executive Summary

This comprehensive implementation plan addresses the architect's feedback and provides detailed specifications for implementing an enterprise-grade idempotency framework in the Fabric Platform. The plan follows enterprise architecture standards and integrates seamlessly with existing components.

---

## üìã Plan Overview

**Epic 1 Stories:**
- **US001:** Batch Job Idempotency Infrastructure (13 Story Points)
- **US002:** API Request Deduplication (8 Story Points)
- **Total:** 21 Story Points

**Timeline:** 4-5 weeks  
**Risk Level:** Medium (well-defined architecture, existing integration points)  
**Business Value:** Prevents data corruption, enables safe job restarts, 99.9% job success rate

---

## üèóÔ∏è Architecture Implementation

### 1. Database Schema Design (Following Architect Recommendations)

```sql
-- ============================================================================
-- IDEMPOTENCY FRAMEWORK DATABASE SCHEMA - ENTERPRISE GRADE
-- Schema: CM3INT (following existing Fabric Platform patterns)
-- ============================================================================

-- Core idempotency key management (per architect guidance)
CREATE TABLE CM3INT.fabric_idempotency_keys (
    idempotency_key         VARCHAR2(128) PRIMARY KEY,
    source_system          VARCHAR2(50) NOT NULL,
    job_name               VARCHAR2(50) NOT NULL,
    transaction_id         VARCHAR2(100),
    file_hash              VARCHAR2(64), -- SHA-256 of input file
    request_hash           VARCHAR2(64), -- SHA-256 of request parameters
    processing_state       VARCHAR2(20) NOT NULL CHECK (processing_state IN 
        ('STARTED', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'EXPIRED')),
    request_payload        CLOB,
    response_payload       CLOB,
    error_details          CLOB,
    correlation_id         VARCHAR2(100) NOT NULL,
    ttl_seconds           NUMBER DEFAULT 86400, -- 24 hours default
    created_date          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_date        TIMESTAMP,
    expires_at            TIMESTAMP,
    retry_count           NUMBER DEFAULT 0,
    max_retries          NUMBER DEFAULT 3,
    created_by           VARCHAR2(50) NOT NULL,
    last_accessed        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processing_node      VARCHAR2(50), -- For distributed processing
    lock_version         NUMBER DEFAULT 0, -- Optimistic locking
    CONSTRAINT uk_idem_composite UNIQUE(source_system, job_name, transaction_id),
    CONSTRAINT fk_idem_source_job FOREIGN KEY (source_system, job_name) 
        REFERENCES batch_configurations(source_system, job_name)
);

-- Processing state audit trail (extending existing audit patterns)
CREATE TABLE CM3INT.fabric_idempotency_audit (
    audit_id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    idempotency_key       VARCHAR2(128) NOT NULL,
    old_state            VARCHAR2(20),
    new_state            VARCHAR2(20),
    state_change_reason  VARCHAR2(500),
    changed_by           VARCHAR2(50) NOT NULL,
    change_date          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processing_context   CLOB, -- JSON metadata
    client_ip            VARCHAR2(45),
    user_agent           VARCHAR2(1000),
    device_fingerprint   VARCHAR2(100),
    session_id           VARCHAR2(100),
    business_context     VARCHAR2(500),
    CONSTRAINT fk_idem_audit_key FOREIGN KEY (idempotency_key) 
        REFERENCES fabric_idempotency_keys(idempotency_key) ON DELETE CASCADE
);

-- Idempotency configuration per job type (enterprise configuration management)
CREATE TABLE CM3INT.fabric_idempotency_config (
    config_id            VARCHAR2(100) PRIMARY KEY,
    config_type          VARCHAR2(20) NOT NULL CHECK (config_type IN ('BATCH_JOB', 'API_ENDPOINT')),
    target_pattern       VARCHAR2(500) NOT NULL, -- job name pattern or endpoint pattern
    enabled              VARCHAR2(1) DEFAULT 'Y' CHECK (enabled IN ('Y', 'N')),
    ttl_hours           NUMBER DEFAULT 24,
    max_retries         NUMBER DEFAULT 3,
    key_generation_strategy VARCHAR2(50) DEFAULT 'AUTO_GENERATED',
    store_request_payload VARCHAR2(1) DEFAULT 'Y' CHECK (store_request_payload IN ('Y', 'N')),
    store_response_payload VARCHAR2(1) DEFAULT 'Y' CHECK (store_response_payload IN ('Y', 'N')),
    cleanup_policy       VARCHAR2(20) DEFAULT 'TTL_BASED' CHECK (cleanup_policy IN ('TTL_BASED', 'MANUAL', 'COUNT_BASED')),
    encryption_required  VARCHAR2(1) DEFAULT 'N' CHECK (encryption_required IN ('Y', 'N')),
    compliance_flags     VARCHAR2(100), -- SOX, PCI, GDPR flags
    description          VARCHAR2(1000),
    created_by           VARCHAR2(50) NOT NULL,
    created_date         TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    modified_by          VARCHAR2(50),
    modified_date        TIMESTAMP,
    version              NUMBER DEFAULT 1
);

-- Performance optimization indexes (per architect requirements)
CREATE INDEX idx_idem_keys_correlation ON fabric_idempotency_keys(correlation_id);
CREATE INDEX idx_idem_keys_job_system ON fabric_idempotency_keys(source_system, job_name);
CREATE INDEX idx_idem_keys_state ON fabric_idempotency_keys(processing_state);
CREATE INDEX idx_idem_keys_expires ON fabric_idempotency_keys(expires_at);
CREATE INDEX idx_idem_keys_created ON fabric_idempotency_keys(created_date);
CREATE INDEX idx_idem_keys_node ON fabric_idempotency_keys(processing_node);

CREATE INDEX idx_idem_audit_key ON fabric_idempotency_audit(idempotency_key);
CREATE INDEX idx_idem_audit_timestamp ON fabric_idempotency_audit(change_date);
CREATE INDEX idx_idem_audit_user ON fabric_idempotency_audit(changed_by);

CREATE INDEX idx_idem_config_pattern ON fabric_idempotency_config(config_type, target_pattern);
CREATE INDEX idx_idem_config_enabled ON fabric_idempotency_config(enabled);

-- Automated cleanup procedure (enterprise maintenance)
CREATE OR REPLACE PROCEDURE cleanup_expired_idempotency_records AS
    v_cleanup_count NUMBER;
    v_audit_cleanup_count NUMBER;
BEGIN
    -- Cleanup expired idempotency records
    DELETE FROM fabric_idempotency_keys 
    WHERE expires_at < CURRENT_TIMESTAMP;
    
    v_cleanup_count := SQL%ROWCOUNT;
    
    -- Cleanup old audit records (90 days retention)
    DELETE FROM fabric_idempotency_audit 
    WHERE change_date < CURRENT_TIMESTAMP - INTERVAL '90' DAY;
    
    v_audit_cleanup_count := SQL%ROWCOUNT;
    
    -- Log cleanup activity
    INSERT INTO fabric_idempotency_audit (
        idempotency_key, 
        new_state, 
        state_change_reason, 
        changed_by,
        processing_context
    ) VALUES (
        'SYSTEM_CLEANUP', 
        'CLEANUP_COMPLETED', 
        'Automated cleanup of expired records', 
        'SYSTEM',
        JSON_OBJECT(
            'records_cleaned' VALUE v_cleanup_count,
            'audit_records_cleaned' VALUE v_audit_cleanup_count
        )
    );
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        -- Log error for monitoring
        INSERT INTO fabric_idempotency_audit (
            idempotency_key, 
            new_state, 
            state_change_reason, 
            changed_by,
            processing_context
        ) VALUES (
            'SYSTEM_CLEANUP', 
            'CLEANUP_FAILED', 
            'Cleanup failed: ' || SQLERRM, 
            'SYSTEM',
            JSON_OBJECT('error_code' VALUE SQLCODE, 'error_message' VALUE SQLERRM)
        );
        COMMIT;
        RAISE;
END;
/

-- Schedule cleanup job (runs every 4 hours)
BEGIN
    DBMS_SCHEDULER.create_job(
        job_name => 'IDEMPOTENCY_CLEANUP_JOB',
        job_type => 'PLSQL_BLOCK',
        job_action => 'BEGIN cleanup_expired_idempotency_records; END;',
        start_date => CURRENT_TIMESTAMP,
        repeat_interval => 'FREQ=HOURLY; INTERVAL=4',
        enabled => TRUE,
        comments => 'Automated cleanup of expired idempotency records'
    );
END;
/
```

### 2. Enterprise Java Implementation

#### 2.1 Entity Layer (JPA Entities)

**File:** `/fabric-core/fabric-batch/src/main/java/com/truist/batch/idempotency/entity/FabricIdempotencyKeyEntity.java`

```java
@Entity
@Table(name = "fabric_idempotency_keys", schema = "CM3INT")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class FabricIdempotencyKeyEntity extends BaseAuditEntity {
    
    @Id
    @Column(name = "idempotency_key", length = 128)
    private String idempotencyKey;
    
    @Column(name = "source_system", length = 50, nullable = false)
    private String sourceSystem;
    
    @Column(name = "job_name", length = 50, nullable = false)
    private String jobName;
    
    @Column(name = "transaction_id", length = 100)
    private String transactionId;
    
    @Column(name = "file_hash", length = 64)
    private String fileHash;
    
    @Column(name = "request_hash", length = 64)
    private String requestHash;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "processing_state", length = 20, nullable = false)
    private ProcessingState processingState;
    
    @Lob
    @Column(name = "request_payload")
    private String requestPayload;
    
    @Lob
    @Column(name = "response_payload")
    private String responsePayload;
    
    @Lob
    @Column(name = "error_details")
    private String errorDetails;
    
    @Column(name = "correlation_id", length = 100, nullable = false)
    private String correlationId;
    
    @Column(name = "ttl_seconds")
    private Integer ttlSeconds = 86400; // 24 hours default
    
    @Column(name = "completed_date")
    private Instant completedDate;
    
    @Column(name = "expires_at", nullable = false)
    private Instant expiresAt;
    
    @Column(name = "retry_count")
    private Integer retryCount = 0;
    
    @Column(name = "max_retries")
    private Integer maxRetries = 3;
    
    @Column(name = "last_accessed")
    private Instant lastAccessed;
    
    @Column(name = "processing_node", length = 50)
    private String processingNode;
    
    @Version
    @Column(name = "lock_version")
    private Integer lockVersion = 0;
    
    @PrePersist
    @PreUpdate
    private void updateTimestamps() {
        this.lastAccessed = Instant.now();
        if (this.expiresAt == null && this.ttlSeconds != null) {
            this.expiresAt = Instant.now().plusSeconds(this.ttlSeconds);
        }
    }
    
    public enum ProcessingState {
        STARTED, IN_PROGRESS, COMPLETED, FAILED, EXPIRED
    }
}
```

**File:** `/fabric-core/fabric-batch/src/main/java/com/truist/batch/idempotency/entity/FabricIdempotencyAuditEntity.java`

```java
@Entity
@Table(name = "fabric_idempotency_audit", schema = "CM3INT")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FabricIdempotencyAuditEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "audit_id")
    private Long auditId;
    
    @Column(name = "idempotency_key", length = 128, nullable = false)
    private String idempotencyKey;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "old_state", length = 20)
    private FabricIdempotencyKeyEntity.ProcessingState oldState;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "new_state", length = 20)
    private FabricIdempotencyKeyEntity.ProcessingState newState;
    
    @Column(name = "state_change_reason", length = 500)
    private String stateChangeReason;
    
    @Column(name = "changed_by", length = 50, nullable = false)
    private String changedBy;
    
    @Column(name = "change_date", nullable = false)
    private Instant changeDate = Instant.now();
    
    @Lob
    @Column(name = "processing_context")
    private String processingContext; // JSON metadata
    
    @Column(name = "client_ip", length = 45)
    private String clientIp;
    
    @Column(name = "user_agent", length = 1000)
    private String userAgent;
    
    @Column(name = "device_fingerprint", length = 100)
    private String deviceFingerprint;
    
    @Column(name = "session_id", length = 100)
    private String sessionId;
    
    @Column(name = "business_context", length = 500)
    private String businessContext;
}
```

#### 2.2 Repository Layer

**File:** `/fabric-core/fabric-batch/src/main/java/com/truist/batch/idempotency/repository/FabricIdempotencyKeyRepository.java`

```java
@Repository
public interface FabricIdempotencyKeyRepository extends JpaRepository<FabricIdempotencyKeyEntity, String> {
    
    @Query("""
        SELECT i FROM FabricIdempotencyKeyEntity i 
        WHERE i.sourceSystem = :sourceSystem 
        AND i.jobName = :jobName 
        AND i.transactionId = :transactionId
        """)
    Optional<FabricIdempotencyKeyEntity> findByJobIdentifiers(
        @Param("sourceSystem") String sourceSystem,
        @Param("jobName") String jobName,
        @Param("transactionId") String transactionId
    );
    
    @Query("""
        SELECT i FROM FabricIdempotencyKeyEntity i 
        WHERE i.correlationId = :correlationId
        """)
    List<FabricIdempotencyKeyEntity> findByCorrelationId(@Param("correlationId") String correlationId);
    
    @Query("""
        SELECT i FROM FabricIdempotencyKeyEntity i 
        WHERE i.processingState = :state 
        AND i.sourceSystem = :sourceSystem
        """)
    List<FabricIdempotencyKeyEntity> findByStateAndSourceSystem(
        @Param("state") FabricIdempotencyKeyEntity.ProcessingState state,
        @Param("sourceSystem") String sourceSystem
    );
    
    @Modifying
    @Query("""
        UPDATE FabricIdempotencyKeyEntity i 
        SET i.processingState = :newState, 
            i.completedDate = :completedDate,
            i.errorDetails = :errorDetails,
            i.lockVersion = i.lockVersion + 1
        WHERE i.idempotencyKey = :idempotencyKey 
        AND i.lockVersion = :expectedVersion
        """)
    int updateStateWithOptimisticLock(
        @Param("idempotencyKey") String idempotencyKey,
        @Param("newState") FabricIdempotencyKeyEntity.ProcessingState newState,
        @Param("completedDate") Instant completedDate,
        @Param("errorDetails") String errorDetails,
        @Param("expectedVersion") Integer expectedVersion
    );
    
    @Query("""
        SELECT COUNT(i) FROM FabricIdempotencyKeyEntity i 
        WHERE i.expiresAt < :currentTime
        """)
    long countExpiredRecords(@Param("currentTime") Instant currentTime);
    
    @Modifying
    @Query("""
        DELETE FROM FabricIdempotencyKeyEntity i 
        WHERE i.expiresAt < :currentTime
        """)
    int deleteExpiredRecords(@Param("currentTime") Instant currentTime);
    
    @Query("""
        SELECT i FROM FabricIdempotencyKeyEntity i 
        WHERE i.processingState = 'IN_PROGRESS' 
        AND i.createdDate < :staleThreshold
        """)
    List<FabricIdempotencyKeyEntity> findStaleInProgressRecords(
        @Param("staleThreshold") Instant staleThreshold
    );
}
```

#### 2.3 Service Layer Implementation

**File:** `/fabric-core/fabric-batch/src/main/java/com/truist/batch/idempotency/service/IdempotencyService.java`

```java
@Service
@Transactional
@Slf4j
public class IdempotencyService {
    
    private final FabricIdempotencyKeyRepository idempotencyKeyRepository;
    private final FabricIdempotencyAuditRepository idempotencyAuditRepository;
    private final IdempotencyKeyGenerator keyGenerator;
    private final IdempotencyConfigService configService;
    private final ObjectMapper objectMapper;
    private final ApplicationEventPublisher eventPublisher;
    
    public IdempotencyService(
            FabricIdempotencyKeyRepository idempotencyKeyRepository,
            FabricIdempotencyAuditRepository idempotencyAuditRepository,
            IdempotencyKeyGenerator keyGenerator,
            IdempotencyConfigService configService,
            ObjectMapper objectMapper,
            ApplicationEventPublisher eventPublisher) {
        this.idempotencyKeyRepository = idempotencyKeyRepository;
        this.idempotencyAuditRepository = idempotencyAuditRepository;
        this.keyGenerator = keyGenerator;
        this.configService = configService;
        this.objectMapper = objectMapper;
        this.eventPublisher = eventPublisher;
    }
    
    /**
     * Process request with idempotency guarantee
     */
    public <T> IdempotencyResult<T> processWithIdempotency(
            IdempotencyRequest request,
            Supplier<T> businessLogic,
            Class<T> responseType) {
        
        String correlationId = generateCorrelationId();
        log.debug("Processing idempotent request with correlation ID: {}", correlationId);
        
        try {
            // Generate or extract idempotency key
            String idempotencyKey = keyGenerator.generateKey(request);
            
            // Check for existing processing
            Optional<FabricIdempotencyKeyEntity> existing = 
                idempotencyKeyRepository.findById(idempotencyKey);
            
            if (existing.isPresent()) {
                return handleExistingRequest(existing.get(), request, responseType);
            }
            
            // Create new idempotency record
            FabricIdempotencyKeyEntity idempotencyEntity = createIdempotencyRecord(
                idempotencyKey, request, correlationId
            );
            
            // Execute business logic
            return executeBusinessLogic(idempotencyEntity, businessLogic, responseType);
            
        } catch (Exception e) {
            log.error("Error in idempotent processing for correlation ID: {}", correlationId, e);
            throw new IdempotencyException("Idempotent processing failed", correlationId, e);
        }
    }
    
    /**
     * Handle existing idempotency request
     */
    private <T> IdempotencyResult<T> handleExistingRequest(
            FabricIdempotencyKeyEntity existing,
            IdempotencyRequest request,
            Class<T> responseType) {
        
        switch (existing.getProcessingState()) {
            case COMPLETED:
                log.debug("Returning cached result for idempotency key: {}", existing.getIdempotencyKey());
                auditStateChange(existing, existing.getProcessingState(), existing.getProcessingState(), 
                    "Cached result returned", request.getRequestContext());
                return IdempotencyResult.fromCached(
                    deserializeResponse(existing.getResponsePayload(), responseType),
                    existing.getIdempotencyKey(),
                    existing.getCorrelationId()
                );
                
            case IN_PROGRESS:
                if (isRequestStale(existing)) {
                    log.warn("Stale in-progress request detected, allowing retry: {}", existing.getIdempotencyKey());
                    return retryStaleRequest(existing, request, responseType);
                } else {
                    log.debug("Request already in progress: {}", existing.getIdempotencyKey());
                    return IdempotencyResult.inProgress(
                        existing.getIdempotencyKey(),
                        existing.getCorrelationId()
                    );
                }
                
            case FAILED:
                if (canRetry(existing)) {
                    log.debug("Retrying failed request: {}", existing.getIdempotencyKey());
                    return retryFailedRequest(existing, request, responseType);
                } else {
                    log.debug("Max retries exceeded for: {}", existing.getIdempotencyKey());
                    return IdempotencyResult.maxRetriesExceeded(
                        existing.getErrorDetails(),
                        existing.getIdempotencyKey(),
                        existing.getCorrelationId()
                    );
                }
                
            case EXPIRED:
                log.debug("Expired request, creating new: {}", existing.getIdempotencyKey());
                return createNewFromExpired(existing, request, responseType);
                
            default:
                throw new IdempotencyException(
                    "Unknown processing state: " + existing.getProcessingState(),
                    existing.getCorrelationId()
                );
        }
    }
    
    /**
     * Execute business logic with idempotency protection
     */
    private <T> IdempotencyResult<T> executeBusinessLogic(
            FabricIdempotencyKeyEntity idempotencyEntity,
            Supplier<T> businessLogic,
            Class<T> responseType) {
        
        try {
            // Update state to IN_PROGRESS
            updateIdempotencyState(
                idempotencyEntity, 
                ProcessingState.IN_PROGRESS, 
                "Business logic execution started"
            );
            
            // Execute business logic
            T result = businessLogic.get();
            
            // Serialize and store result
            String serializedResult = serializeResponse(result);
            idempotencyEntity.setResponsePayload(serializedResult);
            
            // Update state to COMPLETED
            updateIdempotencyState(
                idempotencyEntity, 
                ProcessingState.COMPLETED, 
                "Business logic execution completed successfully"
            );
            
            log.debug("Successfully completed idempotent processing: {}", idempotencyEntity.getIdempotencyKey());
            
            return IdempotencyResult.success(
                result,
                idempotencyEntity.getIdempotencyKey(),
                idempotencyEntity.getCorrelationId()
            );
            
        } catch (Exception e) {
            // Update state to FAILED
            idempotencyEntity.setErrorDetails(formatException(e));
            updateIdempotencyState(
                idempotencyEntity, 
                ProcessingState.FAILED, 
                "Business logic execution failed: " + e.getMessage()
            );
            
            throw new IdempotencyException(
                "Business logic execution failed",
                idempotencyEntity.getCorrelationId(),
                e
            );
        }
    }
    
    /**
     * Update idempotency state with audit trail
     */
    private void updateIdempotencyState(
            FabricIdempotencyKeyEntity entity,
            ProcessingState newState,
            String reason) {
        
        ProcessingState oldState = entity.getProcessingState();
        entity.setProcessingState(newState);
        
        if (newState == ProcessingState.COMPLETED || newState == ProcessingState.FAILED) {
            entity.setCompletedDate(Instant.now());
        }
        
        idempotencyKeyRepository.save(entity);
        auditStateChange(entity, oldState, newState, reason, getCurrentRequestContext());
        
        // Publish event for monitoring
        eventPublisher.publishEvent(new IdempotencyStateChangedEvent(
            entity.getIdempotencyKey(),
            oldState,
            newState,
            entity.getCorrelationId()
        ));
    }
    
    /**
     * Create audit trail for state changes
     */
    private void auditStateChange(
            FabricIdempotencyKeyEntity entity,
            ProcessingState oldState,
            ProcessingState newState,
            String reason,
            RequestContext context) {
        
        FabricIdempotencyAuditEntity audit = FabricIdempotencyAuditEntity.builder()
            .idempotencyKey(entity.getIdempotencyKey())
            .oldState(oldState)
            .newState(newState)
            .stateChangeReason(reason)
            .changedBy(context.getUserId())
            .clientIp(context.getClientIp())
            .userAgent(context.getUserAgent())
            .deviceFingerprint(context.getDeviceFingerprint())
            .sessionId(context.getSessionId())
            .businessContext(entity.getJobName())
            .processingContext(createProcessingContext(entity, context))
            .build();
        
        idempotencyAuditRepository.save(audit);
    }
    
    // Additional helper methods...
    
    private String generateCorrelationId() {
        return "IDEM_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
    }
    
    private boolean isRequestStale(FabricIdempotencyKeyEntity entity) {
        return entity.getCreatedDate().isBefore(
            Instant.now().minus(Duration.ofMinutes(30))
        );
    }
    
    private boolean canRetry(FabricIdempotencyKeyEntity entity) {
        return entity.getRetryCount() < entity.getMaxRetries();
    }
}
```

#### 2.4 Integration with Existing GenericJobConfig

**File Enhancement:** `/fabric-core/fabric-batch/src/main/java/com/truist/batch/config/GenericJobConfig.java`

```java
@Configuration
@EnableBatchProcessing
@ComponentScan(basePackages = {"com.truist.batch", "com.truist.batch.idempotency"})
public class IdempotentGenericJobConfig extends GenericJobConfig {
    
    @Autowired
    private IdempotencyService idempotencyService;
    
    /**
     * Enhanced job with idempotency support
     */
    @Bean
    public Job idempotentGenericJob() {
        return new JobBuilder("idempotentGenericJob", jobRepository)
            .incrementer(new RunIdIncrementer())
            .listener(jobListener)
            .listener(idempotentJobExecutionListener()) // New idempotency listener
            .start(idempotencyCheckStep())
            .next(loadBatchDateStep())
            .next(filePartitionStep(null, null))
            .build();
    }
    
    /**
     * Idempotency check step (runs before main processing)
     */
    @Bean
    public Step idempotencyCheckStep() {
        return new StepBuilder("idempotencyCheckStep", jobRepository)
            .tasklet(idempotencyCheckTasklet(), transactionManager)
            .build();
    }
    
    /**
     * Tasklet to check and register idempotency
     */
    @Bean
    @StepScope
    public Tasklet idempotencyCheckTasklet() {
        return new IdempotencyCheckTasklet(idempotencyService);
    }
    
    /**
     * Job execution listener with idempotency support
     */
    @Bean
    public JobExecutionListener idempotentJobExecutionListener() {
        return new IdempotentJobExecutionListener(idempotencyService);
    }
}
```

**File:** `/fabric-core/fabric-batch/src/main/java/com/truist/batch/idempotency/tasklet/IdempotencyCheckTasklet.java`

```java
@Component
@Slf4j
public class IdempotencyCheckTasklet implements Tasklet {
    
    private final IdempotencyService idempotencyService;
    
    public IdempotencyCheckTasklet(IdempotencyService idempotencyService) {
        this.idempotencyService = idempotencyService;
    }
    
    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        
        StepExecution stepExecution = chunkContext.getStepContext().getStepExecution();
        JobParameters jobParameters = stepExecution.getJobExecution().getJobParameters();
        
        // Extract job identification parameters
        String sourceSystem = jobParameters.getString("sourceSystem");
        String jobName = jobParameters.getString("jobName");
        String fileName = jobParameters.getString("fileName");
        String filePath = jobParameters.getString("filePath");
        
        // Create idempotency request
        IdempotencyRequest request = IdempotencyRequest.builder()
            .sourceSystem(sourceSystem)
            .jobName(jobName)
            .transactionId(fileName)
            .filePath(filePath)
            .jobParameters(jobParameters.getParameters())
            .requestContext(getCurrentRequestContext(stepExecution))
            .build();
        
        // Check idempotency
        IdempotencyResult<Boolean> result = idempotencyService.processWithIdempotency(
            request,
            () -> {
                log.info("Idempotency check passed for job: {}/{}", sourceSystem, jobName);
                return true;
            },
            Boolean.class
        );
        
        // Handle result
        switch (result.getStatus()) {
            case SUCCESS:
                // New execution, continue processing
                stepExecution.getExecutionContext().putString("idempotencyKey", result.getIdempotencyKey());
                stepExecution.getExecutionContext().putString("correlationId", result.getCorrelationId());
                log.info("New idempotent job execution: {} (correlation: {})", 
                    result.getIdempotencyKey(), result.getCorrelationId());
                return RepeatStatus.FINISHED;
                
            case CACHED_RESULT:
                // Job already completed, skip processing
                log.info("Job already completed with idempotency key: {}", result.getIdempotencyKey());
                stepExecution.setExitStatus(ExitStatus.COMPLETED);
                return RepeatStatus.FINISHED;
                
            case IN_PROGRESS:
                // Job currently running elsewhere
                throw new JobExecutionException(
                    String.format("Job already in progress with idempotency key: %s", result.getIdempotencyKey())
                );
                
            case MAX_RETRIES_EXCEEDED:
                // Too many retries
                throw new JobExecutionException(
                    String.format("Maximum retries exceeded for idempotency key: %s", result.getIdempotencyKey())
                );
                
            default:
                throw new JobExecutionException(
                    String.format("Unknown idempotency result status: %s", result.getStatus())
                );
        }
    }
    
    private RequestContext getCurrentRequestContext(StepExecution stepExecution) {
        return RequestContext.builder()
            .userId("BATCH_SYSTEM")
            .sessionId(stepExecution.getJobExecution().getJobInstance().getInstanceId().toString())
            .clientIp("localhost")
            .userAgent("Spring Batch Job Execution")
            .businessContext("Batch Job Processing")
            .build();
    }
}
```

---

## üß™ Testing Strategy

### Unit Tests (Target: 90% Coverage)

**File:** `/fabric-core/fabric-batch/src/test/java/com/truist/batch/idempotency/service/IdempotencyServiceTest.java`

```java
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(OrderAnnotation.class)
class IdempotencyServiceTest {
    
    @Mock private FabricIdempotencyKeyRepository idempotencyKeyRepository;
    @Mock private FabricIdempotencyAuditRepository idempotencyAuditRepository;
    @Mock private IdempotencyKeyGenerator keyGenerator;
    @Mock private IdempotencyConfigService configService;
    @Mock private ObjectMapper objectMapper;
    @Mock private ApplicationEventPublisher eventPublisher;
    
    @InjectMocks private IdempotencyService idempotencyService;
    
    private static final String TEST_IDEMPOTENCY_KEY = "test-key-12345";
    private static final String TEST_CORRELATION_ID = "test-corr-12345";
    
    @Test
    @Order(1)
    void shouldCreateNewIdempotencyRecord_WhenNoExistingRecord() {
        // Given
        IdempotencyRequest request = createTestRequest();
        when(keyGenerator.generateKey(request)).thenReturn(TEST_IDEMPOTENCY_KEY);
        when(idempotencyKeyRepository.findById(TEST_IDEMPOTENCY_KEY)).thenReturn(Optional.empty());
        
        // When
        IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
            request,
            () -> "Success",
            String.class
        );
        
        // Then
        assertThat(result.getStatus()).isEqualTo(IdempotencyStatus.SUCCESS);
        assertThat(result.getData()).isEqualTo("Success");
        assertThat(result.getIdempotencyKey()).isEqualTo(TEST_IDEMPOTENCY_KEY);
        
        verify(idempotencyKeyRepository).save(any(FabricIdempotencyKeyEntity.class));
        verify(idempotencyAuditRepository, atLeastOnce()).save(any(FabricIdempotencyAuditEntity.class));
    }
    
    @Test
    @Order(2)
    void shouldReturnCachedResult_WhenRequestAlreadyCompleted() {
        // Given
        IdempotencyRequest request = createTestRequest();
        FabricIdempotencyKeyEntity existingEntity = createCompletedEntity();
        
        when(keyGenerator.generateKey(request)).thenReturn(TEST_IDEMPOTENCY_KEY);
        when(idempotencyKeyRepository.findById(TEST_IDEMPOTENCY_KEY)).thenReturn(Optional.of(existingEntity));
        when(objectMapper.readValue(anyString(), eq(String.class))).thenReturn("Cached Result");
        
        // When
        IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
            request,
            () -> "New Result",
            String.class
        );
        
        // Then
        assertThat(result.getStatus()).isEqualTo(IdempotencyStatus.CACHED_RESULT);
        assertThat(result.getData()).isEqualTo("Cached Result");
        assertThat(result.getIdempotencyKey()).isEqualTo(TEST_IDEMPOTENCY_KEY);
        
        verify(idempotencyKeyRepository, never()).save(any(FabricIdempotencyKeyEntity.class));
    }
    
    @Test
    @Order(3)
    void shouldReturnInProgress_WhenRequestCurrentlyProcessing() {
        // Given
        IdempotencyRequest request = createTestRequest();
        FabricIdempotencyKeyEntity existingEntity = createInProgressEntity();
        
        when(keyGenerator.generateKey(request)).thenReturn(TEST_IDEMPOTENCY_KEY);
        when(idempotencyKeyRepository.findById(TEST_IDEMPOTENCY_KEY)).thenReturn(Optional.of(existingEntity));
        
        // When
        IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
            request,
            () -> "New Result",
            String.class
        );
        
        // Then
        assertThat(result.getStatus()).isEqualTo(IdempotencyStatus.IN_PROGRESS);
        assertThat(result.getIdempotencyKey()).isEqualTo(TEST_IDEMPOTENCY_KEY);
    }
    
    @Test
    @Order(4)
    void shouldRetryFailedRequest_WhenRetryCountBelowMax() {
        // Given
        IdempotencyRequest request = createTestRequest();
        FabricIdempotencyKeyEntity existingEntity = createFailedEntity();
        existingEntity.setRetryCount(1);
        existingEntity.setMaxRetries(3);
        
        when(keyGenerator.generateKey(request)).thenReturn(TEST_IDEMPOTENCY_KEY);
        when(idempotencyKeyRepository.findById(TEST_IDEMPOTENCY_KEY)).thenReturn(Optional.of(existingEntity));
        
        // When
        IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
            request,
            () -> "Retry Success",
            String.class
        );
        
        // Then
        assertThat(result.getStatus()).isEqualTo(IdempotencyStatus.SUCCESS);
        assertThat(result.getData()).isEqualTo("Retry Success");
    }
    
    @Test
    @Order(5)
    void shouldRejectRequest_WhenMaxRetriesExceeded() {
        // Given
        IdempotencyRequest request = createTestRequest();
        FabricIdempotencyKeyEntity existingEntity = createFailedEntity();
        existingEntity.setRetryCount(3);
        existingEntity.setMaxRetries(3);
        
        when(keyGenerator.generateKey(request)).thenReturn(TEST_IDEMPOTENCY_KEY);
        when(idempotencyKeyRepository.findById(TEST_IDEMPOTENCY_KEY)).thenReturn(Optional.of(existingEntity));
        
        // When
        IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
            request,
            () -> "Should Not Execute",
            String.class
        );
        
        // Then
        assertThat(result.getStatus()).isEqualTo(IdempotencyStatus.MAX_RETRIES_EXCEEDED);
    }
    
    // Performance test
    @Test
    @Order(6)
    void shouldCompleteWithinPerformanceThreshold() {
        // Given
        IdempotencyRequest request = createTestRequest();
        when(keyGenerator.generateKey(request)).thenReturn(TEST_IDEMPOTENCY_KEY);
        when(idempotencyKeyRepository.findById(TEST_IDEMPOTENCY_KEY)).thenReturn(Optional.empty());
        
        // When
        long startTime = System.currentTimeMillis();
        
        IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
            request,
            () -> "Performance Test",
            String.class
        );
        
        long executionTime = System.currentTimeMillis() - startTime;
        
        // Then
        assertThat(result.getStatus()).isEqualTo(IdempotencyStatus.SUCCESS);
        assertThat(executionTime).isLessThan(100); // < 100ms for idempotency overhead
    }
    
    // Helper methods
    private IdempotencyRequest createTestRequest() {
        return IdempotencyRequest.builder()
            .sourceSystem("TEST_SYSTEM")
            .jobName("TEST_JOB")
            .transactionId("test_transaction_123")
            .filePath("/test/data/file.csv")
            .requestContext(RequestContext.builder()
                .userId("test_user")
                .clientIp("127.0.0.1")
                .build())
            .build();
    }
    
    private FabricIdempotencyKeyEntity createCompletedEntity() {
        return FabricIdempotencyKeyEntity.builder()
            .idempotencyKey(TEST_IDEMPOTENCY_KEY)
            .sourceSystem("TEST_SYSTEM")
            .jobName("TEST_JOB")
            .processingState(ProcessingState.COMPLETED)
            .responsePayload("\"Cached Result\"")
            .correlationId(TEST_CORRELATION_ID)
            .build();
    }
    
    private FabricIdempotencyKeyEntity createInProgressEntity() {
        return FabricIdempotencyKeyEntity.builder()
            .idempotencyKey(TEST_IDEMPOTENCY_KEY)
            .sourceSystem("TEST_SYSTEM")
            .jobName("TEST_JOB")
            .processingState(ProcessingState.IN_PROGRESS)
            .correlationId(TEST_CORRELATION_ID)
            .createdDate(Instant.now())
            .build();
    }
    
    private FabricIdempotencyKeyEntity createFailedEntity() {
        return FabricIdempotencyKeyEntity.builder()
            .idempotencyKey(TEST_IDEMPOTENCY_KEY)
            .sourceSystem("TEST_SYSTEM")
            .jobName("TEST_JOB")
            .processingState(ProcessingState.FAILED)
            .errorDetails("Test failure")
            .correlationId(TEST_CORRELATION_ID)
            .retryCount(0)
            .maxRetries(3)
            .build();
    }
}
```

### Integration Tests

**File:** `/fabric-core/fabric-batch/src/test/java/com/truist/batch/idempotency/integration/IdempotencyIntegrationTest.java`

```java
@SpringBootTest
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
@Transactional
class IdempotencyIntegrationTest {
    
    @Autowired private IdempotencyService idempotencyService;
    @Autowired private FabricIdempotencyKeyRepository idempotencyKeyRepository;
    @Autowired private TestEntityManager entityManager;
    
    @Test
    @DisplayName("End-to-end idempotent batch job execution")
    void shouldExecuteBatchJobIdempotently() {
        // Given
        IdempotencyRequest request = createBatchJobRequest();
        
        // When - First execution
        IdempotencyResult<BatchJobResult> result1 = idempotencyService.processWithIdempotency(
            request,
            () -> new BatchJobResult("Job completed successfully", 1000, 0),
            BatchJobResult.class
        );
        
        // Then - First execution should succeed
        assertThat(result1.getStatus()).isEqualTo(IdempotencyStatus.SUCCESS);
        assertThat(result1.getData().getRecordsProcessed()).isEqualTo(1000);
        
        // When - Second execution (duplicate)
        IdempotencyResult<BatchJobResult> result2 = idempotencyService.processWithIdempotency(
            request,
            () -> new BatchJobResult("Should not execute", 999, 999),
            BatchJobResult.class
        );
        
        // Then - Second execution should return cached result
        assertThat(result2.getStatus()).isEqualTo(IdempotencyStatus.CACHED_RESULT);
        assertThat(result2.getData().getRecordsProcessed()).isEqualTo(1000); // Same as first
        assertThat(result2.getIdempotencyKey()).isEqualTo(result1.getIdempotencyKey());
    }
    
    @Test
    @DisplayName("Concurrent idempotent request handling")
    void shouldHandleConcurrentRequests() throws InterruptedException {
        // Given
        IdempotencyRequest request = createBatchJobRequest();
        CountDownLatch latch = new CountDownLatch(2);
        List<IdempotencyResult<String>> results = new CopyOnWriteArrayList<>();
        
        // When - Execute concurrent requests
        Thread thread1 = new Thread(() -> {
            try {
                IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
                    request,
                    () -> {
                        try { Thread.sleep(500); } catch (InterruptedException e) {}
                        return "Result from thread 1";
                    },
                    String.class
                );
                results.add(result);
            } finally {
                latch.countDown();
            }
        });
        
        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(100); // Start slightly later
                IdempotencyResult<String> result = idempotencyService.processWithIdempotency(
                    request,
                    () -> "Result from thread 2 (should not execute)",
                    String.class
                );
                results.add(result);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                latch.countDown();
            }
        });
        
        thread1.start();
        thread2.start();
        
        // Then - Wait for completion
        assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
        assertThat(results).hasSize(2);
        
        // Verify one succeeded, one got in-progress or cached result
        long successCount = results.stream()
            .mapToLong(r -> r.getStatus() == IdempotencyStatus.SUCCESS ? 1 : 0)
            .sum();
        
        long inProgressCount = results.stream()
            .mapToLong(r -> r.getStatus() == IdempotencyStatus.IN_PROGRESS ? 1 : 0)
            .sum();
        
        assertThat(successCount).isEqualTo(1);
        assertThat(inProgressCount).isLessThanOrEqualTo(1);
    }
    
    @Test
    @DisplayName("Database cleanup of expired records")
    void shouldCleanupExpiredRecords() {
        // Given - Create expired record
        FabricIdempotencyKeyEntity expiredRecord = FabricIdempotencyKeyEntity.builder()
            .idempotencyKey("expired-key-123")
            .sourceSystem("TEST_SYSTEM")
            .jobName("TEST_JOB")
            .processingState(ProcessingState.COMPLETED)
            .expiresAt(Instant.now().minus(Duration.ofHours(25))) // Expired
            .correlationId("test-corr-123")
            .build();
        
        entityManager.persistAndFlush(expiredRecord);
        
        // When - Execute cleanup
        int deletedCount = idempotencyKeyRepository.deleteExpiredRecords(Instant.now());
        
        // Then
        assertThat(deletedCount).isEqualTo(1);
        assertThat(idempotencyKeyRepository.findById("expired-key-123")).isEmpty();
    }
    
    private IdempotencyRequest createBatchJobRequest() {
        return IdempotencyRequest.builder()
            .sourceSystem("HR_SYSTEM")
            .jobName("EMPLOYEE_DATA_LOAD")
            .transactionId("emp_data_20250807.csv")
            .filePath("/data/hr/emp_data_20250807.csv")
            .requestContext(RequestContext.builder()
                .userId("batch_user")
                .clientIp("10.0.0.1")
                .userAgent("Spring Batch Agent")
                .build())
            .build();
    }
    
    @Data
    @AllArgsConstructor
    static class BatchJobResult {
        private String message;
        private int recordsProcessed;
        private int recordsFailed;
    }
}
```

---

## üìä Implementation Timeline

### Week 1-2: Database and Core Infrastructure
- **Day 1-2:** Database schema creation and testing
- **Day 3-5:** Entity layer and repository implementation
- **Day 6-8:** Core service layer development
- **Day 9-10:** Unit testing and code review

### Week 3-4: Integration and API Layer
- **Day 1-3:** GenericJobConfig integration
- **Day 4-5:** API request deduplication implementation
- **Day 6-7:** Integration testing
- **Day 8-10:** Performance testing and optimization

---

## üéØ Success Criteria

- [ ] All batch jobs are idempotent and safely restartable
- [ ] API requests support deduplication with configurable TTL
- [ ] Performance overhead < 5% for idempotency operations
- [ ] 90%+ unit test coverage achieved
- [ ] Integration tests pass for all scenarios
- [ ] Comprehensive audit trail for all operations
- [ ] Zero disruption to existing batch jobs

---

## üö® Risk Mitigation

### Technical Risks
- **Database Performance:** Comprehensive indexing and query optimization
- **Memory Usage:** TTL-based cleanup and response payload size limits
- **Concurrency Issues:** Optimistic locking and database-level constraints

### Operational Risks
- **False Duplicates:** Robust key generation and thorough testing
- **Data Inconsistency:** Transactional integrity and rollback procedures

---

## ‚úÖ **APPROVAL REQUEST**

This comprehensive implementation plan addresses all architect feedback and provides:

1. **Enterprise-grade database design** following CM3INT schema patterns
2. **Complete Java implementation** with existing component integration
3. **Comprehensive testing strategy** with performance benchmarks
4. **Security and compliance** framework integration
5. **Detailed timeline and risk mitigation**

**Request for Architect Final Approval:** Please review and approve this plan before implementation begins.

---

**Document Version:** 2.0  
**Created:** August 2025  
**Status:** Pending Architect Approval

¬© 2025 Truist Financial Corporation. All rights reserved.