// src/pages/TemplateConfigurationPage/TemplateConfigurationPage.tsx
import React, { useState, useEffect } from 'react';
import {
    Box,
    Card,
    CardContent,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Button,
    Typography,
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableRow,
    TextField,
    Chip,
    Alert,
    CircularProgress,
    Container,
    Stepper,
    Step,
    StepLabel,
    Grid,
    Paper
} from '@mui/material';
import { Download, Upload, Save, Settings, OpenInNew } from '@mui/icons-material';
import { useConfigurationContext } from '../../contexts/ConfigurationContext';
import { templateApiService } from '../../services/api/templateApi';
import { FileTypeTemplate, FieldTemplate, FieldMappingConfig, TemplateToConfigurationResult } from '../../types/template';
import { SourceSystem } from '../../types/configuration';
import { useNavigate } from 'react-router-dom';
import { useSourceSystems } from '../../hooks/useSourceSystems';

const steps = ['Select Template', 'Configure Mappings', 'Generate & Save'];

export const TemplateConfigurationPage: React.FC = () => {
    const [activeStep, setActiveStep] = useState(0);
    const [fileTypes, setFileTypes] = useState<FileTypeTemplate[]>([]);
    const [selectedFileType, setSelectedFileType] = useState('');
    const [transactionTypes, setTransactionTypes] = useState<string[]>([]);
    const [selectedTransactionType, setSelectedTransactionType] = useState('');
    const [templateFields, setTemplateFields] = useState<FieldTemplate[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [templateJobName, setTemplateJobName] = useState('');
    const [success, setSuccess] = useState<string | null>(null);
    const [generatedConfig, setGeneratedConfig] = useState<any>(null);
    const [localSelectedSourceSystem, setLocalSelectedSourceSystem] = useState<SourceSystem | null>(null);
    const [uploadedFileName, setUploadedFileName] = useState<string | null>(null);

    const navigate = useNavigate();
    
    const { sourceSystems, isLoading: sourceSystemsLoading } = useSourceSystems();

    const {
        selectedSourceSystem,
        selectedJob,
        saveConfiguration,
        selectSourceSystem
    } = useConfigurationContext();

    // Initialize local source system with context value
    useEffect(() => {
        if (selectedSourceSystem && !localSelectedSourceSystem) {
            setLocalSelectedSourceSystem(selectedSourceSystem);
        }
    }, [selectedSourceSystem, localSelectedSourceSystem]);

    // Load file types on mount
    useEffect(() => {
        fetchFileTypes();
    }, []);

    // Load transaction types when file type changes
    useEffect(() => {
        if (selectedFileType) {
            fetchTransactionTypes(selectedFileType);
        }
    }, [selectedFileType]);

    // Load template fields when both are selected
    useEffect(() => {
        if (selectedFileType && selectedTransactionType) {
            fetchTemplateFields(selectedFileType, selectedTransactionType);
            setActiveStep(1);
        }
    }, [selectedFileType, selectedTransactionType]);

    // Auto-generate job name when template selection changes
    useEffect(() => {
        if (selectedFileType && selectedTransactionType) {
            const autoGeneratedJobName = `${selectedFileType}-${selectedTransactionType}`;
            setTemplateJobName(autoGeneratedJobName);
            console.log('Auto-generated job name:', autoGeneratedJobName);
        } else {
            setTemplateJobName('');
        }
    }, [selectedFileType, selectedTransactionType]);

    const fetchFileTypes = async () => {
        try {
            setLoading(true);
            const types = await templateApiService.getFileTypes();
            setFileTypes(
                types.map((t: any) => ({
                    ...t,
                    recordLength: t.recordLength ?? 0
                }))
            );
        } catch (error) {
            setError('Failed to load file types');
        } finally {
            setLoading(false);
        }
    };

    const fetchTransactionTypes = async (fileType: string) => {
        try {
            const data = await templateApiService.getTransactionTypes(fileType);
            setTransactionTypes(data);
            if (data.length === 1) {
                setSelectedTransactionType(data[0]);
            }
        } catch (error) {
            console.error('Error fetching transaction types:', error);
        }
    };

    const fetchTemplateFields = async (fileType: string, transactionType: string) => {
        setLoading(true);
        try {
            const data = await templateApiService.getTemplateFields(fileType, transactionType);
            setTemplateFields(data);
            setError(null);
        } catch (error) {
            setError('Failed to load template fields');
            console.error('Error fetching template fields:', error);
        } finally {
            setLoading(false);
        }
    };

    const handleSourceFieldChange = (fieldIndex: number, sourceField: string) => {
        const updated = [...templateFields];
        updated[fieldIndex].sourceField = sourceField;
        setTemplateFields(updated);
    };

    const handleTransformationChange = (fieldIndex: number, transformationType: string) => {
        const updated = [...templateFields];
        updated[fieldIndex].transformationType = transformationType as any;
        
        // Reset transformation-specific fields when type changes
        if (transformationType === 'source') {
            updated[fieldIndex].value = undefined;
            updated[fieldIndex].sources = undefined;
            updated[fieldIndex].conditions = [];
        } else if (transformationType === 'constant') {
            updated[fieldIndex].sources = undefined;
            updated[fieldIndex].conditions = [];
        } else if (transformationType === 'composite') {
            updated[fieldIndex].value = undefined;
            updated[fieldIndex].conditions = [];
            if (!updated[fieldIndex].sources) {
                updated[fieldIndex].sources = [{ field: '' }];
            }
        } else if (transformationType === 'conditional') {
            updated[fieldIndex].value = undefined;
            updated[fieldIndex].sources = undefined;
            if (!updated[fieldIndex].conditions || updated[fieldIndex].conditions?.length === 0) {
                updated[fieldIndex].conditions = [{ ifExpr: '', then: '', elseExpr: '' }];
            }
        }
        
        setTemplateFields(updated);
    };

    const handleSourceSystemChange = (sourceSystemId: string) => {
        const sourceSystem = sourceSystems.find(s => s.id === sourceSystemId);
        if (sourceSystem) {
            setLocalSelectedSourceSystem(sourceSystem);
            selectSourceSystem(sourceSystemId);
        }
    };

    const generateConfiguration = async () => {
        // Validation checks
        if (!selectedFileType) {
            setError('Please select a file type');
            return;
        }

        if (!selectedTransactionType) {
            setError('Please select a transaction type');
            return;
        }

        if (!localSelectedSourceSystem) {
            setError('Please select a source system');
            return;
        }

        const jobName = templateJobName || (selectedJob?.name || selectedJob?.jobName);
        if (!jobName) {
            setError('Please ensure a job name is available');
            return;
        }

        try {
            setLoading(true);
            setError(null);

            console.log('üöÄ Starting configuration generation...', {
                fileType: selectedFileType,
                transactionType: selectedTransactionType,
                sourceSystem: localSelectedSourceSystem.id,
                jobName: jobName
            });

            // Step 1: Generate configuration from template
            let configWithMetadata;

            try {
                configWithMetadata = await templateApiService.createConfigurationFromTemplateWithMetadata(
                    selectedFileType,
                    selectedTransactionType,
                    localSelectedSourceSystem.id,
                    jobName
                );

                console.log('‚úÖ Template configuration generated:', configWithMetadata);
            } catch (templateError) {
                console.error('‚ùå Template generation failed:', templateError);
                const errorMsg = templateError instanceof Error ? templateError.message : 'Unknown error';
                throw new Error(`Failed to generate template configuration: ${errorMsg}`);
            }

            // Step 2: Merge user customizations from the UI
            const enhancedFields = configWithMetadata.fields.map((fieldMapping: any, index: number) => {
                const userCustomization = templateFields[index];

                return {
                    ...fieldMapping,
                    sourceField: userCustomization?.sourceField || fieldMapping.sourceField || '',
                    transformationType: userCustomization?.transformationType || fieldMapping.transformationType || 'source'
                };
            });

            const finalConfiguration = {
                ...configWithMetadata,
                fields: enhancedFields
            };

            console.log('‚úÖ Final configuration prepared:', finalConfiguration);
            setGeneratedConfig(finalConfiguration);

            // Step 3: Simple save attempt
            try {
    console.log('üîÑ Saving template configuration...', finalConfiguration);
    
    // Create configuration in the format expected by backend
    const configForBackend = {
        sourceSystem: finalConfiguration.sourceSystem,
        jobName: finalConfiguration.jobName,
        transactionType: finalConfiguration.transactionType, // "200"
        description: finalConfiguration.description || `Generated from ${selectedFileType}/${selectedTransactionType} template`,
        fieldMappings: finalConfiguration.fields.map((field: any) => ({
            fieldName: field.fieldName,
            sourceField: field.sourceField || '',
            targetField: field.targetField,
            targetPosition: field.targetPosition,
            length: field.length,
            dataType: field.dataType,
            transformationType: field.transformationType,
            transactionType: field.transactionType || finalConfiguration.transactionType,
            value: field.value,
            defaultValue: field.defaultValue,
            format: field.format
        })),
        createdBy: 'template-user',
        version: 1
    };

    console.log('üì¶ Sending to backend:', configForBackend);

    // Call the backend API directly instead of context save
    const response = await fetch('http://localhost:8080/ui/mappings/save', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(configForBackend)
    });

    if (response.ok) {
        const result = await response.text();
        console.log('‚úÖ Configuration saved successfully! ID:', result);
        
        setActiveStep(2);
        const { templateMetadata } = configWithMetadata;
        const successMessage = `‚úÖ Configuration saved successfully!

Template: ${templateMetadata.fileType}/${templateMetadata.transactionType}
Job Name: ${jobName}
Transaction Type: ${finalConfiguration.transactionType}
Fields saved: ${finalConfiguration.fields.length}
Configuration ID: ${result}

üéâ Configuration saved to database!`;

        setSuccess(successMessage);
        setError(null);
    } else {
        throw new Error(`Backend save failed: ${response.status} ${response.statusText}`);
    }

            } catch (saveError) {
                console.warn('‚ö†Ô∏è Save operation failed:', saveError);
                
                // Show template generation success with next steps
                setActiveStep(2);
                const { templateMetadata } = configWithMetadata;
                const successMessage = `‚úÖ Template configuration generated successfully!

Template: ${templateMetadata.fileType}/${templateMetadata.transactionType}
Job Name: ${jobName}
Source System: ${localSelectedSourceSystem.name}
Fields prepared: ${enhancedFields.length}

üìã Next Steps:
1. Click "Navigate to Manual Config" below to set up the job
2. The template structure is ready to be applied
3. You can copy the field mappings shown below

üí° Template generation was successful - just need to set up the job context for saving.`;

                setSuccess(successMessage);
                setError(null);
            }

        } catch (error) {
            console.error('‚ùå Configuration generation failed:', error);
            
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            setError(`Failed to generate configuration: ${errorMessage}`);
            setActiveStep(1);
            
        } finally {
            setLoading(false);
            console.log('üèÅ Configuration generation process completed');
        }
    };

    const navigateToManualConfig = () => {
        if (localSelectedSourceSystem && templateJobName) {
            navigate(`/configuration/${localSelectedSourceSystem.id}/${templateJobName}`);
        }
    };

    const copyConfigToClipboard = () => {
        if (generatedConfig) {
            const configText = JSON.stringify(generatedConfig, null, 2);
            navigator.clipboard.writeText(configText).then(() => {
                alert('Configuration copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }
    };

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setLoading(true);
        setError(null);
        setUploadedFileName(file.name);

        try {
            // Validate file type
            const allowedTypes = ['.xlsx', '.xls', '.csv'];
            const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
            
            if (!allowedTypes.includes(fileExtension)) {
                throw new Error('Invalid file type. Please upload Excel (.xlsx, .xls) or CSV (.csv) files only.');
            }

            // Validate file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                throw new Error('File size too large. Please upload files smaller than 5MB.');
            }

            // Parse the file based on type
            let parsedData: any[] = [];
            
            if (fileExtension === '.csv') {
                parsedData = await parseCSVFile(file);
            } else {
                parsedData = await parseExcelFile(file);
            }

            // Validate parsed data
            if (!parsedData || parsedData.length === 0) {
                throw new Error('No data found in the uploaded file.');
            }

            // Map the parsed data to template fields
            const mappedFields = mapUploadedDataToFields(parsedData);
            
            if (mappedFields.length > 0) {
                // Update template fields with uploaded configuration
                const updatedFields = templateFields.map((field, index) => {
                    const mappedField = mappedFields.find(m => 
                        m.fieldName?.toLowerCase() === field.fieldName?.toLowerCase() ||
                        m.targetField?.toLowerCase() === field.fieldName?.toLowerCase()
                    );
                    
                    if (mappedField) {
                        return {
                            ...field,
                            sourceField: mappedField.sourceField || field.sourceField,
                            transformationType: mappedField.transformationType || field.transformationType,
                            value: mappedField.value || field.value,
                            defaultValue: mappedField.defaultValue || field.defaultValue,
                            delimiter: mappedField.delimiter || field.delimiter,
                            sources: mappedField.sources || field.sources,
                            conditions: mappedField.conditions || field.conditions
                        };
                    }
                    return field;
                });
                
                setTemplateFields(updatedFields);
                setSuccess(`Successfully imported configuration from ${file.name}. ${mappedFields.length} field mappings were applied.`);
            } else {
                setError('No matching fields found in the uploaded file. Please ensure the file contains columns like "fieldName", "sourceField", "transformationType", etc.');
            }

        } catch (error) {
            console.error('File upload error:', error);
            const errorMessage = error instanceof Error ? error.message : 'Failed to parse uploaded file';
            setError(`Upload failed: ${errorMessage}`);
            setUploadedFileName(null);
        } finally {
            setLoading(false);
            // Reset file input
            event.target.value = '';
        }
    };

    const parseCSVFile = (file: File): Promise<any[]> => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const text = e.target?.result as string;
                    const lines = text.split('\n').filter(line => line.trim());
                    
                    if (lines.length < 2) {
                        reject(new Error('CSV file must contain at least a header row and one data row.'));
                        return;
                    }

                    const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                    const data = lines.slice(1).map(line => {
                        const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
                        const row: any = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index] || '';
                        });
                        return row;
                    });
                    
                    resolve(data);
                } catch (error) {
                    reject(new Error('Failed to parse CSV file. Please ensure it is properly formatted.'));
                }
            };
            reader.onerror = () => reject(new Error('Failed to read CSV file.'));
            reader.readAsText(file);
        });
    };

    const parseExcelFile = (file: File): Promise<any[]> => {
        return new Promise((resolve, reject) => {
            // For now, we'll show an informative error since we need a library like xlsx to parse Excel
            reject(new Error('Excel file parsing requires additional library. Please use CSV format for now, or implement xlsx library support.'));
        });
    };

    const mapUploadedDataToFields = (data: any[]): any[] => {
        const mappedFields: any[] = [];
        
        data.forEach(row => {
            // Common column name variations
            const fieldName = row.fieldName || row.field_name || row.FieldName || row['Field Name'] || '';
            const sourceField = row.sourceField || row.source_field || row.SourceField || row['Source Field'] || '';
            const transformationType = row.transformationType || row.transformation_type || row.TransformationType || row['Transformation Type'] || row.type || 'source';
            const value = row.value || row.constantValue || row.constant_value || row.Value || row['Constant Value'] || '';
            const defaultValue = row.defaultValue || row.default_value || row.DefaultValue || row['Default Value'] || '';
            
            // Enhanced: Handle transformation-specific fields
            const delimiter = row.delimiter || row.Delimiter || '';
            const conditionIf = row.condition_if || row.conditionIf || row.ConditionIf || row['Condition If'] || '';
            const conditionThen = row.condition_then || row.conditionThen || row.ConditionThen || row['Condition Then'] || '';
            const conditionElse = row.condition_else || row.conditionElse || row.ConditionElse || row['Condition Else'] || '';
            
            if (fieldName) {
                const mappedField: any = {
                    fieldName,
                    sourceField,
                    transformationType: transformationType.toLowerCase(),
                    value,
                    defaultValue
                };
                
                // Add transformation-specific configurations
                if (transformationType.toLowerCase() === 'composite') {
                    mappedField.delimiter = delimiter || ' ';
                    if (sourceField) {
                        // Parse comma-separated source fields for composite
                        mappedField.sources = sourceField.split(',').map((field: string) => ({ field: field.trim() }));
                    }
                }
                
                if (transformationType.toLowerCase() === 'conditional') {
                    if (conditionIf && conditionThen) {
                        mappedField.conditions = [{
                            ifExpr: conditionIf,
                            then: conditionThen,
                            elseExpr: conditionElse || ''
                        }];
                    }
                }
                
                mappedFields.push(mappedField);
            }
        });
        
        return mappedFields;
    };

    const exportCurrentTemplate = () => {
        if (!templateFields || templateFields.length === 0) {
            setError('No template fields available to export.');
            return;
        }

        const csvContent = generateCSVFromTemplate(templateFields);
        downloadCSV(csvContent, `template_${selectedFileType}_${selectedTransactionType}_${new Date().toISOString().split('T')[0]}.csv`);
    };

    const downloadSampleCSV = () => {
        const sampleData = [
            {
                fieldName: 'emp_id',
                sourceField: 'employee_id',
                transformationType: 'source',
                value: '',
                defaultValue: '',
                delimiter: '',
                condition_if: '',
                condition_then: '',
                condition_else: '',
                description: 'Direct mapping from source field'
            },
            {
                fieldName: 'location_code',
                sourceField: '',
                transformationType: 'constant',
                value: '100020',
                defaultValue: '100020',
                delimiter: '',
                condition_if: '',
                condition_then: '',
                condition_else: '',
                description: 'Fixed constant value'
            },
            {
                fieldName: 'full_name',
                sourceField: 'first_name,last_name',
                transformationType: 'composite',
                value: '',
                defaultValue: '',
                delimiter: ' ',
                condition_if: '',
                condition_then: '',
                condition_else: '',
                description: 'Combine first_name and last_name with space delimiter'
            },
            {
                fieldName: 'employee_status',
                sourceField: 'status_code',
                transformationType: 'conditional',
                value: '',
                defaultValue: 'UNKNOWN',
                delimiter: '',
                condition_if: 'status_code == "A"',
                condition_then: 'ACTIVE',
                condition_else: 'INACTIVE',
                description: 'Simple if-then-else: Active if status_code is A, otherwise Inactive'
            },
            {
                fieldName: 'department_name',
                sourceField: 'dept_id',
                transformationType: 'conditional',
                value: '',
                defaultValue: 'OTHER',
                delimiter: '',
                condition_if: 'dept_id == "HR" ? "Human Resources" : (dept_id == "IT" ? "Information Technology" : (dept_id == "FIN" ? "Finance" : "Other Department"))',
                condition_then: '',
                condition_else: '',
                description: 'Complex nested if-then-else: Map department codes to full names'
            },
            {
                fieldName: 'full_address',
                sourceField: 'street,city,state,zip',
                transformationType: 'composite',
                value: '',
                defaultValue: '',
                delimiter: ', ',
                condition_if: '',
                condition_then: '',
                condition_else: '',
                description: 'Combine address fields with comma-space delimiter'
            },
            {
                fieldName: 'salary_grade',
                sourceField: 'annual_salary',
                transformationType: 'conditional',
                value: '',
                defaultValue: 'ENTRY',
                delimiter: '',
                condition_if: 'annual_salary >= 100000 ? "SENIOR" : (annual_salary >= 75000 ? "MID" : (annual_salary >= 50000 ? "JUNIOR" : "ENTRY"))',
                condition_then: '',
                condition_else: '',
                description: 'Multi-level salary grading based on annual salary ranges'
            }
        ];
        
        const csvContent = generateCSVFromData(sampleData);
        downloadCSV(csvContent, 'sample_field_mapping_with_examples.csv');
    };

    const generateCSVFromTemplate = (fields: FieldTemplate[]): string => {
        const headers = ['fieldName', 'sourceField', 'transformationType', 'value', 'defaultValue', 'length', 'dataType', 'required'];
        const rows = fields.map(field => [
            field.fieldName || '',
            field.sourceField || '',
            field.transformationType || 'source',
            field.value || '',
            field.defaultValue || '',
            field.length || '',
            field.dataType || '',
            field.required || 'N'
        ]);
        
        return [headers, ...rows].map(row => 
            row.map(cell => `"${cell}"`).join(',')
        ).join('\n');
    };

    const generateCSVFromData = (data: any[]): string => {
        if (data.length === 0) return '';
        
        const headers = Object.keys(data[0]);
        const rows = data.map(item => 
            headers.map(header => `"${item[header] || ''}"`).join(',')
        );
        
        return [headers.map(h => `"${h}"`).join(','), ...rows].join('\n');
    };

    const downloadCSV = (content: string, filename: string) => {
        const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        
        if (link.download !== undefined) {
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };

    return (
        <Container maxWidth="xl" sx={{ py: 3 }}>
            <Typography variant="h4" gutterBottom sx={{ color: 'primary.main', mb: 3 }}>
                Template-Based Configuration
            </Typography>

            {/* Stepper */}
            <Paper sx={{ p: 2, mb: 3 }}>
                <Stepper activeStep={activeStep} alternativeLabel>
                    {steps.map((label) => (
                        <Step key={label}>
                            <StepLabel>{label}</StepLabel>
                        </Step>
                    ))}
                </Stepper>
            </Paper>

            {/* Error Alert */}
            {error && (
                <Alert
                    severity="error"
                    sx={{ mb: 3 }}
                    onClose={() => setError(null)}
                    action={
                        <Button color="inherit" size="small" onClick={() => setError(null)}>
                            DISMISS
                        </Button>
                    }
                >
                    <Typography variant="body2">
                        <strong>Error:</strong> {error}
                    </Typography>
                    <Typography variant="caption" sx={{ mt: 1, display: 'block' }}>
                        Check the browser console for detailed error information.
                    </Typography>
                </Alert>
            )}

            {/* Success Alert */}
            {success && (
                <Alert
                    severity="success"
                    sx={{ mb: 3 }}
                    onClose={() => setSuccess(null)}
                    action={
                        <Box sx={{ display: 'flex', gap: 1 }}>
                            {generatedConfig && (
                                <>
                                    <Button 
                                        color="inherit" 
                                        size="small" 
                                        onClick={navigateToManualConfig}
                                        startIcon={<OpenInNew />}
                                    >
                                        Navigate to Manual Config
                                    </Button>
                                    <Button 
                                        color="inherit" 
                                        size="small" 
                                        onClick={copyConfigToClipboard}
                                    >
                                        Copy Config
                                    </Button>
                                </>
                            )}
                            <Button color="inherit" size="small" onClick={() => setSuccess(null)}>
                                DISMISS
                            </Button>
                        </Box>
                    }
                >
                    <Typography variant="body2" sx={{ whiteSpace: 'pre-line' }}>
                        {success}
                    </Typography>
                </Alert>
            )}

            {/* Step 1: Template Selection */}
            <Card sx={{ mb: 3 }}>
                <CardContent>
                    <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Settings /> 1. Select Template
                    </Typography>

                    <Grid container spacing={2}>
                        <Grid item xs={12} md={3}>
                            <FormControl fullWidth>
                                <InputLabel>File Type</InputLabel>
                                <Select
                                    value={selectedFileType}
                                    onChange={(e) => setSelectedFileType(e.target.value)}
                                    label="File Type"
                                    disabled={loading}
                                >
                                    {fileTypes.map((ft) => (
                                        <MenuItem key={ft.fileType} value={ft.fileType}>
                                            {ft.fileType} - {ft.description}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>

                        <Grid item xs={12} md={3}>
                            <FormControl fullWidth>
                                <InputLabel>Transaction Type</InputLabel>
                                <Select
                                    value={selectedTransactionType}
                                    onChange={(e) => setSelectedTransactionType(e.target.value)}
                                    label="Transaction Type"
                                    disabled={!selectedFileType || loading}
                                >
                                    {transactionTypes.map((tt) => (
                                        <MenuItem key={tt} value={tt}>
                                            {tt}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>

                        <Grid item xs={12} md={3}>
                            <FormControl fullWidth>
                                <InputLabel>Source System</InputLabel>
                                <Select
                                    value={localSelectedSourceSystem?.id || ''}
                                    onChange={(e) => handleSourceSystemChange(e.target.value)}
                                    label="Source System"
                                    disabled={sourceSystemsLoading}
                                >
                                    {sourceSystems.map((system) => (
                                        <MenuItem key={system.id} value={system.id}>
                                            {system.name} - {system.systemType}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>

                        <Grid item xs={12} md={3}>
                            <TextField
                                fullWidth
                                size="small"
                                label="Job Name"
                                value={templateJobName}
                                onChange={(e) => setTemplateJobName(e.target.value)}
                                disabled={!selectedFileType || !selectedTransactionType}
                                helperText={
                                    selectedFileType && selectedTransactionType
                                        ? "Auto-generated from template (editable)"
                                        : "Select template to generate job name"
                                }
                            />
                        </Grid>
                    </Grid>

                    {selectedFileType && selectedTransactionType && templateJobName && (
                        <Box sx={{ mt: 2, p: 2, bgcolor: 'primary.main', color: 'primary.contrastText', borderRadius: 1 }}>
                            <Typography variant="body2">
                                ‚úì Selected: {selectedFileType} - {selectedTransactionType} ‚Üí Job: {templateJobName}
                            </Typography>
                        </Box>
                    )}
                </CardContent>
            </Card>

            {/* Step 2: Template Fields */}
            {selectedFileType && selectedTransactionType && (
                <Card sx={{ mb: 3 }}>
                    <CardContent>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                            <Typography variant="h6">
                                2. Configure Field Mappings
                            </Typography>
                            <Chip
                                label={`${templateFields.length} fields`}
                                color="primary"
                                variant="outlined"
                            />
                        </Box>

                        <Alert severity="info" sx={{ mb: 2 }}>
                            Target structure is pre-configured from template. Only specify source fields and transformation logic.
                        </Alert>
                        
                        {uploadedFileName && (
                            <Alert severity="success" sx={{ mb: 2 }}>
                                üìÅ Configuration imported from: <strong>{uploadedFileName}</strong>
                            </Alert>
                        )}
                        
                        <Alert severity="info" sx={{ mb: 2 }}>
                            <Typography variant="body2">
                                üí° <strong>Pro Tip:</strong> You can import field mappings from CSV files. 
                                <strong>Click "Download Sample CSV"</strong> to see examples including:
                                <br />
                                ‚Ä¢ <strong>Composite:</strong> Combine multiple fields (e.g., first_name + last_name)
                                <br />
                                ‚Ä¢ <strong>Simple Conditional:</strong> if status_code == "A" then "ACTIVE" else "INACTIVE"
                                <br />
                                ‚Ä¢ <strong>Complex Conditional:</strong> Multi-level if-then-else chains for mappings
                                <br />
                                ‚Ä¢ <strong>Constant:</strong> Fixed values for all records
                            </Typography>
                        </Alert>

                        {loading ? (
                            <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
                                <CircularProgress />
                            </Box>
                        ) : (
                            <Box sx={{ overflowX: 'auto' }}>
                                <Table size="small">
                                    <TableHead>
                                        <TableRow>
                                            <TableCell>Position</TableCell>
                                            <TableCell>Target Field</TableCell>
                                            <TableCell>Length</TableCell>
                                            <TableCell>Data Type</TableCell>
                                            <TableCell>Format</TableCell>
                                            <TableCell>Source Field</TableCell>
                                            <TableCell>Transformation</TableCell>
                                        </TableRow>
                                    </TableHead>
                                    <TableBody>
                                        {templateFields.map((field, index) => (
                                            <TableRow key={field.fieldName} hover>
                                                <TableCell align="center">
                                                    <Chip size="small" label={field.targetPosition} />
                                                </TableCell>
                                                <TableCell>
                                                    <Typography variant="body2" fontWeight="bold">
                                                        {field.fieldName}
                                                    </Typography>
                                                    {field.required === 'Y' && (
                                                        <Chip size="small" label="Required" color="error" sx={{ ml: 1 }} />
                                                    )}
                                                </TableCell>
                                                <TableCell>{field.length}</TableCell>
                                                <TableCell>
                                                    <Chip size="small" label={field.dataType} variant="outlined" />
                                                </TableCell>
                                                <TableCell>{field.format || '-'}</TableCell>
                                                <TableCell>
                                                    <TextField
                                                        size="small"
                                                        placeholder="Source field name"
                                                        value={field.sourceField || ''}
                                                        onChange={(e) => handleSourceFieldChange(index, e.target.value)}
                                                        sx={{ width: 150 }}
                                                    />
                                                </TableCell>
                                                <TableCell>
                                                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, minWidth: 200 }}>
                                                        <Select
                                                            size="small"
                                                            value={field.transformationType || 'source'}
                                                            onChange={(e) => handleTransformationChange(index, e.target.value)}
                                                            sx={{ width: 120 }}
                                                        >
                                                            <MenuItem value="source">Source</MenuItem>
                                                            <MenuItem value="constant">Constant</MenuItem>
                                                            <MenuItem value="composite">Composite</MenuItem>
                                                            <MenuItem value="conditional">Conditional</MenuItem>
                                                        </Select>
                                                        
                                                        {/* Constant Value Configuration */}
                                                        {field.transformationType === 'constant' && (
                                                            <TextField
                                                                size="small"
                                                                placeholder="Constant value"
                                                                value={field.value || field.defaultValue || ''}
                                                                onChange={(e) => {
                                                                    const updated = [...templateFields];
                                                                    updated[index].value = e.target.value;
                                                                    setTemplateFields(updated);
                                                                }}
                                                                sx={{ width: 120 }}
                                                                label="Value"
                                                            />
                                                        )}
                                                        
                                                        {/* Composite Configuration */}
                                                        {field.transformationType === 'composite' && (
                                                            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
                                                                <Typography variant="caption" color="text.secondary">
                                                                    Source Fields:
                                                                </Typography>
                                                                {(field.sources || [{ field: '' }]).map((source: { field: string }, sourceIndex: number) => (
                                                                    <Box key={sourceIndex} sx={{ display: 'flex', gap: 0.5, alignItems: 'center' }}>
                                                                        <TextField
                                                                            size="small"
                                                                            placeholder={`Field ${sourceIndex + 1}`}
                                                                            value={source.field || ''}
                                                                            onChange={(e) => {
                                                                                const updated = [...templateFields];
                                                                                if (!updated[index].sources) updated[index].sources = [];
                                                                                updated[index].sources![sourceIndex] = { field: e.target.value };
                                                                                setTemplateFields(updated);
                                                                            }}
                                                                            sx={{ width: 100 }}
                                                                        />
                                                                        <Button
                                                                            size="small"
                                                                            variant="outlined"
                                                                            onClick={() => {
                                                                                const updated = [...templateFields];
                                                                                if (!updated[index].sources) updated[index].sources = [];
                                                                                updated[index].sources!.push({ field: '' });
                                                                                setTemplateFields(updated);
                                                                            }}
                                                                            sx={{ minWidth: 'auto', px: 1 }}
                                                                        >
                                                                            +
                                                                        </Button>
                                                                        {field.sources && field.sources.length > 1 && (
                                                                            <Button
                                                                                size="small"
                                                                                variant="outlined"
                                                                                color="error"
                                                                                onClick={() => {
                                                                                    const updated = [...templateFields];
                                                                                    if (updated[index].sources) {
                                                                                        updated[index].sources!.splice(sourceIndex, 1);
                                                                                    }
                                                                                    setTemplateFields(updated);
                                                                                }}
                                                                                sx={{ minWidth: 'auto', px: 1 }}
                                                                            >
                                                                                -
                                                                            </Button>
                                                                        )}
                                                                    </Box>
                                                                ))}
                                                                <TextField
                                                                    size="small"
                                                                    placeholder="Delimiter (e.g., ' ', '_', ',')"
                                                                    value={field.delimiter || ''}
                                                                    onChange={(e) => {
                                                                        const updated = [...templateFields];
                                                                        updated[index].delimiter = e.target.value;
                                                                        setTemplateFields(updated);
                                                                    }}
                                                                    sx={{ width: 120 }}
                                                                    label="Delimiter"
                                                                />
                                                            </Box>
                                                        )}
                                                        
                                                        {/* Conditional Configuration */}
                                                        {field.transformationType === 'conditional' && (
                                                            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
                                                                <Typography variant="caption" color="text.secondary">
                                                                    Conditions:
                                                                </Typography>
                                                                {(field.conditions || [{ ifExpr: '', then: '', elseExpr: '' }]).map((condition: { ifExpr: string; then: string; elseExpr?: string }, condIndex: number) => (
                                                                    <Box key={condIndex} sx={{ display: 'flex', flexDirection: 'column', gap: 0.5, p: 1, border: '1px solid #ddd', borderRadius: 1 }}>
                                                                        <TextField
                                                                            size="small"
                                                                            placeholder="If condition (e.g., field == 'value')"
                                                                            value={condition.ifExpr || ''}
                                                                            onChange={(e) => {
                                                                                const updated = [...templateFields];
                                                                                if (!updated[index].conditions) updated[index].conditions = [];
                                                                                updated[index].conditions![condIndex] = {
                                                                                    ...updated[index].conditions![condIndex],
                                                                                    ifExpr: e.target.value
                                                                                };
                                                                                setTemplateFields(updated);
                                                                            }}
                                                                            label="If"
                                                                            sx={{ width: 150 }}
                                                                        />
                                                                        <TextField
                                                                            size="small"
                                                                            placeholder="Then value"
                                                                            value={condition.then || ''}
                                                                            onChange={(e) => {
                                                                                const updated = [...templateFields];
                                                                                if (!updated[index].conditions) updated[index].conditions = [];
                                                                                updated[index].conditions![condIndex] = {
                                                                                    ...updated[index].conditions![condIndex],
                                                                                    then: e.target.value
                                                                                };
                                                                                setTemplateFields(updated);
                                                                            }}
                                                                            label="Then"
                                                                            sx={{ width: 150 }}
                                                                        />
                                                                        <TextField
                                                                            size="small"
                                                                            placeholder="Else value (optional)"
                                                                            value={condition.elseExpr || ''}
                                                                            onChange={(e) => {
                                                                                const updated = [...templateFields];
                                                                                if (!updated[index].conditions) updated[index].conditions = [];
                                                                                updated[index].conditions![condIndex] = {
                                                                                    ...updated[index].conditions![condIndex],
                                                                                    elseExpr: e.target.value
                                                                                };
                                                                                setTemplateFields(updated);
                                                                            }}
                                                                            label="Else"
                                                                            sx={{ width: 150 }}
                                                                        />
                                                                        {field.conditions && field.conditions.length > 1 && (
                                                                            <Button
                                                                                size="small"
                                                                                variant="outlined"
                                                                                color="error"
                                                                                onClick={() => {
                                                                                    const updated = [...templateFields];
                                                                                    if (updated[index].conditions) {
                                                                                        updated[index].conditions!.splice(condIndex, 1);
                                                                                    }
                                                                                    setTemplateFields(updated);
                                                                                }}
                                                                                sx={{ width: 'fit-content', alignSelf: 'flex-end' }}
                                                                            >
                                                                                Remove Condition
                                                                            </Button>
                                                                        )}
                                                                    </Box>
                                                                ))}
                                                                <Button
                                                                    size="small"
                                                                    variant="outlined"
                                                                    onClick={() => {
                                                                        const updated = [...templateFields];
                                                                        if (!updated[index].conditions) updated[index].conditions = [];
                                                                        updated[index].conditions!.push({ ifExpr: '', then: '', elseExpr: '' });
                                                                        setTemplateFields(updated);
                                                                    }}
                                                                    sx={{ width: 'fit-content' }}
                                                                >
                                                                    Add Condition
                                                                </Button>
                                                            </Box>
                                                        )}
                                                    </Box>
                                                </TableCell>
                                            </TableRow>
                                        ))}
                                    </TableBody>
                                </Table>
                            </Box>
                        )}
                    </CardContent>
                </Card>
            )}

            {/* Step 3: Actions */}
            {templateFields.length > 0 && (
                <Card>
                    <CardContent>
                        <Typography variant="h6" gutterBottom>
                            3. Generate Configuration
                        </Typography>

                        <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                            <Button
                                variant="contained"
                                startIcon={loading ? <CircularProgress size={20} /> : <Save />}
                                onClick={generateConfiguration}
                                disabled={loading || !localSelectedSourceSystem || !templateJobName}
                            >
                                Generate & Save Configuration
                            </Button>

                            <Button
                                variant="outlined"
                                startIcon={<Download />}
                                disabled={loading}
                                onClick={exportCurrentTemplate}
                            >
                                Export Template
                            </Button>
                            
                            <Button
                                variant="outlined"
                                startIcon={<Download />}
                                disabled={loading}
                                onClick={downloadSampleCSV}
                                color="secondary"
                            >
                                Download Sample CSV
                            </Button>

                            <input
                                accept=".xlsx,.xls,.csv"
                                style={{ display: 'none' }}
                                id="config-upload-button"
                                type="file"
                                onChange={handleFileUpload}
                            />
                            <label htmlFor="config-upload-button">
                                <Button
                                    variant="outlined"
                                    component="span"
                                    startIcon={<Upload />}
                                    disabled={loading}
                                >
                                    Import Configuration
                                </Button>
                            </label>
                        </Box>

                        {(!localSelectedSourceSystem || !templateJobName) && (
                            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                                {!localSelectedSourceSystem
                                    ? "Please select a source system from the dropdown above."
                                    : "Please select a template to generate a job name."
                                }
                            </Typography>
                        )}
                    </CardContent>
                </Card>
            )}

            {/* Generated Configuration Display */}
            {generatedConfig && activeStep === 2 && (
                <Card sx={{ mt: 3 }}>
                    <CardContent>
                        <Typography variant="h6" gutterBottom>
                            Generated Configuration Summary
                        </Typography>
                        
                        <Box sx={{ bgcolor: 'grey.100', p: 2, borderRadius: 1, mb: 2 }}>
                            <Typography variant="body2">
                                <strong>Job:</strong> {generatedConfig.jobName}<br/>
                                <strong>Source System:</strong> {generatedConfig.sourceSystem}<br/>
                                <strong>Transaction Type:</strong> {generatedConfig.transactionType}<br/>
                                <strong>Fields:</strong> {generatedConfig.fields?.length || 0}
                            </Typography>
                        </Box>

                        <Typography variant="subtitle2" gutterBottom>
                            Field Mappings:
                        </Typography>
                        
                        {generatedConfig.fields?.slice(0, 5).map((field: any, index: number) => (
                            <Typography key={index} variant="body2" sx={{ fontFamily: 'monospace', fontSize: '0.8rem' }}>
                                {field.targetPosition}. {field.fieldName} ‚Üí {field.sourceField || '(no source)'} 
                                ({field.transformationType})
                            </Typography>
                        ))}
                        
                        {generatedConfig.fields?.length > 5 && (
                            <Typography variant="body2" color="text.secondary">
                                ... and {generatedConfig.fields.length - 5} more fields
                            </Typography>
                        )}
                    </CardContent>
                </Card>
            )}
        </Container>
    );
};

export default TemplateConfigurationPage;